#!/bin/bash

useForm=0
hasBuffer=0
buffer=
path=
gotRead=0
sleepLen=1
genState=0
genIndex=14
genKeys=( "sensitivity" "calhigh" "calhigh" "callow" "deadzone" "speedmax" "speedmin" "projkey" "proj" "path" "port" "host" "ssidkey" "ssid" )

# Parses arguments
while [[ $# -gt 0 ]]; do
	case $1 in
		# Sets the path/device to use for output
		-o|--out)
			path=$2
			shift
			;;
		# Sets the number of seconds to sleep before writing the data
		-s|--sleep)
			sleepLen=$2
			shift
			;;
		# Sets read to continue reading after exiting configuration mode
		-r|--read)
			gotRead=1
			;;
		# Prints help/usage message
		-h|--help)
			echo "Usage: ./configure [ options ] [ filepath ]"
			echo "	Multiple filepaths and/or options are concatenated"
			echo "	Unless -o is used, first usb serial device found will be used"
			echo "	Automatically uses -f if no filepath or -e option was used"
			echo "OPTIONS:"
			echo "	-h, --help    Prints help information"
			echo "	-r, --read    Reads logs from device until disconnected or terminated"
			echo "	-o, --out     Sets the output file/device to use, requires 1 argument"
			echo "	-f, --form    Displays a form for sending configurations to the output"
			echo "	-e, --eval    Sends configuration key-value pair to the output, requires 1 argument"
			echo "	-s, --sleep   Sets the delay in seconds before writing data, requires 1 argument"
			exit
			;;
		# Use generator
		-f|--form)
			useForm=1
			;;
		# Uses argument strings as is instead of as path
		-e|--eval)
			hasBuffer=1
			buffer+="$2\n"
			shift
			;;
		# Rejects invalid commands
		-*)
			echo "Invalid command" $1
			exit
			;;
		# Gets buffer from argument path or uses it as is after eval
		*)
			hasBuffer=1
			buffer+="$(cat $1)\n"
			;;
	esac
	shift
done

# Tries to automatically find a serial device
if [[ -z $path ]]; then
	if [[ $(uname) == "Darwin" ]]; then
		path=`ls /dev/cu.usbserial-* 2>/dev/null | head -1`
	elif [[ $(uname) == "Linux" ]]; then
		path=`ls /dev/ttyUSB* 2> /dev/null | head -1`
	fi
	if [[ -z $path ]]; then
		echo "Unable to auto detect device path"
		exit
	fi
fi

# Only reads if no data is defined
if [[ $useForm -eq 0 && $hasBuffer -eq 0 && $gotRead -eq 1 ]]; then
	cat < $path
	exit
fi

# Creates a new configuration if buffer was not defined or form flag was defined
if [[ $useForm -eq 1 || $hasBuffer -eq 0 ]]; then
	# Prints property list
	echo "[*] SSID"
	echo "[ ] SSID Passphrase"
	echo "[ ] Host"
	echo "[ ] Port"
	echo "[ ] Path"
	echo "[ ] Project"
	echo "[ ] Project Password"
	echo "[ ] Minimum Speed"
	echo "[ ] Maximum Speed"
	echo "[ ] Deadzone"
	echo "[ ] Calibrate Low"
	echo "[ ] Calibrate High"
	echo "[ ] Sensitivity"
	echo "[ ] Exit"
	printf "< Navigate [ Up/Down ], Start editing / Stop editing [ Enter ] >"
	printf "\r\x1b["$genIndex"A["

	# Reads input until exited from interface
	while read -rsn1 key; do
		# Processes input on non escape character
		if [[ $key != $'\x1b' ]]; then
			if [[ $genIndex == 1 ]]; then
				break
			fi
			# Moves to the right of the key
			printf "\x1b[32C: \x1b[K"

			# Prints character if not started with enter key
			if [[ $key != '' ]]; then
				printf $key
			fi

			# Adds input to buffer
			read value
			buffer+=${genKeys[$genIndex-1]}=$key$value'\n'

			# Moves back to selected line
			printf "\x1b[F["

		# Processes escape sequence
		else
			# Ignores non escape sequence character
			read -rsn1 key
			if [[ $key != '[' ]]; then
				continue
			fi

			# Removes indicator for previous line
			printf "\r[ "

			# Processes arrow keys
			read -rsn1 key
			if [[ $key == 'A' && $genIndex -lt 14 ]]; then
				genIndex=$(( $genIndex + 1 ))
				printf "\x1b[A"
			elif [[ $key == 'B' && $genIndex -gt 1 ]]; then
				genIndex=$(( $genIndex - 1 ))
				printf "\x1b[B"
			fi

			# Adds indicator for new line
			printf "\r[*\b"
		fi
	done
	printf '\n\n'

	# Throws on empty buffer
	if [[ -z $buffer ]]; then
		echo "No data to write"
		exit
	fi
fi

# Ensures buffer will exit configuration mode
buffer+='\n'

# Writes buffer to device
sleep $sleepLen; printf "$buffer" > $path &

# Reads data until configuration mode is exited
if [[ $gotRead -eq 0 ]]; then
	sed "/^Done/q" $path
# Reads data until exited
else
	cat < $path
fi
